<!DOCTYPE html>
<html lang="ko" xmlns:th="http://www.thymeleaf.org">
<head>
    <meta charset="UTF-8">
    <title>관리자 페이지</title>
    <link href="/static/default-ui.css" rel="stylesheet"/>
    <link href="/static/ui.css" rel="stylesheet"/>
    <link href="/static/table.css" rel="stylesheet"/>
    
    <link rel="stylesheet" as="style" crossorigin href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard@v1.3.9/dist/web/static/pretendard.min.css" />
    <script src="https://cdn.jsdelivr.net/npm/hls.js@1"></script>
    <style>
        #camera {
            width: 100%;
            height: 100%;
        }

        #buttons {
            min-width: 60%;
        }

        #camBox {
            overflow: hidden;
            position: relative;
            max-width: 60%;
            max-height: 60vh;

            gap: 10px;
        }

        #cv1 {
            position: absolute;
            top: 0;
            left: 0;
        }

    </style>
    <script>
        window.onload = () => {
            window.roi = true;
            window.zoom = false;
            reset();
        }
        function elem(name, value) {
            const elem = document.createElement('input');
            elem.type = 'hidden';
            elem.name = name;
            elem.id = name;
            elem.value = value;
            return elem;
        }
        function onDelete(form) {
            form.appendChild(elem("_method", "delete"));
            return true;
        }
        function onRoiSubmit(form) {
            if (form.submited === "add") {
                return onAdd(form);
            } else if (form.submited === "delete") {
                return onDelete(form);
            }
            return false;
        }
        function onAdd(form) {
            if (!window.lastPos) {
                alert("ROI를 지정해주세요.");
                return false; // no roi
            }
            form.appendChild(elem("cameraId", camId));

            for (const [k, v] of Object.entries(window.lastPos)) {
                form.appendChild(elem(k, v));
            }

            return true;
        }

        function reset() {
            window.lastPos = null;
            const ctx = canvas.getContext("2d");
            clearScreen(ctx);
        }
    </script>
</head>
<body>
<div class="full-width center">
    <div th:if="${camera == null}">
        <p>
            그런 카메라는 존재하지 않습니다.
        </p>
        <a href="/admin">관리자 메뉴로 돌아가기</a>
    </div>
    <div class="gap-1rem flex flex-col center m-1rem grow" th:if="${camera != null}">
        <div class="flex w-40p gap-1rem">
            <button class="w-80p" onclick="window.roi = !window.roi;reset()">ROI 표시/숨김</button>
            <button class="w-20p" onclick="toggleZoom()">확대/축소</button>
        </div>
        <div id="camBox" class="flex grow flex-col">
            <video id="camera" autoplay></video>
            <canvas class="canvas" id="cv1" oncontextmenu="return false"></canvas>
        </div>
        <div class="flex grow flex-col gap-1rem" id="buttons">
            <form action="/roi" method="post" onsubmit="return onRoiSubmit(this)">
                <div class="flex flex-row gap-1rem">
                    <label for="parkingNum" class="full-text self-center font-18px">
                        <span>선택 된 주차장 번호: </span>
                    </label>
                    <select id="parkingNum" name="parkingNum">
                        <th:block th:each="parking : ${parkingROI}">
                            <option th:value="${parking.getParking().getParkingNum()}"
                                    th:text="${parking.getParking().getParkingNum()}"/>
                        </th:block>
                    </select>
                    <button type="submit" value="add" onclick="this.form.submited=this.value">ROI 추가</button>
                    <button type="submit" value="delete" onclick="this.form.submited=this.value">ROI 제거</button>
                </div>
            </form>
            <button onclick="reset()">초기화</button>

            <button class="a-like-button" onclick="window.close('','_parent','');">관리자 메뉴로 돌아가기</button>
        </div>
    </div>
    <script th:if="${camera != null}" th:inline="javascript">
        /*<![CDATA[*/
        const camId = /*[[${camera.getCamId()}]]*/null;

        const box = document.getElementById('camBox');
        const video = document.getElementById('camera');
        const canvas = document.getElementById("cv1");


        function drawPredefinedROI(ctx) {
            if (!window.roi) return;
            let x, y, w, h, text, mat;
            const {scaledX, scaledY} = getScale();
            /*[# th:each="roi : ${parkingROI}"]*//*[# th:if="${roi.x != null}"]*/
            x = /*[[${roi.getX()}]]*/0;
            y = /*[[${roi.getY()}]]*/0;
            w = /*[[${roi.getWidth()}]]*/0;
            h = /*[[${roi.getHeight()}]]*/0;
            text = "[[${roi.getParking().getParkingNum()}]]";
            ctx.font = "24px Pretendard";
            mat = ctx.measureText(text);
            ctx.fillText(text, (x + w / 2) / scaledX - mat.width / 2, (y + h / 2) / scaledY);
            /*[# th:if="${roi.getInCar() != null}"]*/
            text = /*[[${roi.getInCar().getCarId()}]]*/null;
            ctx.font = "18px Pretendard";
            mat = ctx.measureText(text);
            ctx.fillText(text, (x + w / 2) / scaledX - mat.width / 2, (y + h) / scaledY + mat.actualBoundingBoxAscent + mat.actualBoundingBoxDescent);
            /*[/]*/
            
            drawRect(ctx, x / scaledX, y / scaledY, (x + w) / scaledX, (y + h) / scaledY, "#ff0");
            /*[/]*//*[/]*/
        }

        const videoSrc = `${window.location.origin}/cam/${camId}/index.m3u8`;
        if (Hls.isSupported()) {
            const hls = new Hls();
            window.globHls = hls;
            hls.loadSource(videoSrc);
            hls.attachMedia(video);
            hls.on(Hls.Events.MANIFEST_PARSED, function () {
                video.play();
            });
            hls.on(Hls.Events.BUFFER_CODECS, function (_, ev) {
                const div = document.getElementById("camBox");

                window.vidScale = ev.video.metadata;
                div.width = window.vidScale.x;
                div.height = window.vidScale.y;

                canvas.width = video.offsetWidth;
                canvas.height = video.offsetHeight;
            });
        } else if (video.canPlayType('application/vnd.apple.mpegurl')) {
            video.src = videoSrc;
            video.addEventListener('loadedmetadata', function () {
                video.play();
            });
        }

        const resizeHook = () => {
            canvas.width = video.offsetWidth;
            canvas.height = video.offsetHeight;
            drawPredefinedROI(canvas.getContext("2d"));
        };
        window.onresize = resizeHook;
        video.onresize = resizeHook;

        let startPos;

        function getScale() {
            const {width: vidWidth, height: vidHeight} = window.vidScale;
            const scaledX = vidWidth / canvas.clientWidth;
            const scaledY = vidHeight / canvas.clientHeight;

            return {scaledX, scaledY};
        }

        function getOffset(x, y) {
            const { scaledX, scaledY } = getScale();

            return {x: scaledX * x, y: scaledY * y, ogX: x, ogY: y};
        }

        function clearScreen(ctx) {
            ctx.clearRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);
            drawPredefinedROI(ctx);
        }

        function drawRect(ctx, x, y, x2, y2, color = "#f00") {
            ctx.beginPath();
            ctx.moveTo(x, y);
            ctx.lineTo(x2, y);
            ctx.lineTo(x2, y2);
            ctx.lineTo(x, y2);
            ctx.lineTo(x, y);
            ctx.lineWidth = 2;
            ctx.strokeStyle = color;
            ctx.stroke();
        }
        
        function toggleZoom() {
            window.zoom = !window.zoom;
            if (!window.zoomContext) window.zoomContext = {ogX: box.offsetWidth / 2, ogY: box.offsetHeight / 2};

            moveZoomUsingContext();
            if (!zoom) {
                video.style = canvas.style = "";
            }
        }

        canvas.onmousedown = ev => {
            if (ev.buttons === 1) {
                if (!startPos) {
                    startPos = getOffset(ev.layerX, ev.layerY);
                }
            }
        }

        canvas.onmousemove = ev => {
            if (ev.buttons === 1) {
                if (!window.roi) return;
                if (ev.buttons === 1 && startPos) {
                    const {ogX, ogY} = getOffset(ev.layerX, ev.layerY);
                    const {ogX: startX, ogY: startY} = startPos;
                    const ctx = canvas.getContext("2d");
                    clearScreen(ctx);
                    drawRect(ctx, ogX, ogY, startX, startY);
                }
            }
        }

        box.onmousemove = ev => {
            if (ev.buttons !== 2) return;
            let {ogX, ogY} = window.zoomContext;
            ogX += ev.movementX;
            ogY += ev.movementY;
            window.zoomContext = {ogX, ogY};

            moveZoomUsingContext();
        }
        
        function moveZoomUsingContext() {
            if (!zoom) return;
            const {ogX, ogY} = zoomContext;
            const percentX = ogX / box.offsetWidth * 100;
            const percentY = ogY / box.offsetHeight * 100;
            
            const scaler = `transform: scale(${window.zoom ? 200 : 100}%) translateX(${percentX - 50}%) translateY(${percentY - 50}%);`;
            video.style = scaler;
            canvas.style = scaler;
        }
        
        canvas.onmouseup = ev => {
            if (!startPos) return;
            if (!window.roi) return;
            const {x: startX, y: startY, ogX: x1, ogY: y1} = startPos;
            startPos = null;

            const ctx = canvas.getContext("2d");
            const {x, y, ogX: x2, ogY: y2} = getOffset(ev.layerX, ev.layerY);

            window.lastPos = {
                x: Math.round(Math.min(startX, x)),
                y: Math.round(Math.min(startY, y)),
                width: Math.round(Math.max(startX, x) - Math.min(startX, x)),
                height: Math.round(Math.max(startY, y) - Math.min(startY, y)),
            }


            clearScreen(ctx);
            drawRect(ctx, x1, y1, x2, y2);
        }

        canvas.onmouseleave = () => {
            if (!window.roi) return;
            if (startPos) {
                const ctx = canvas.getContext("2d");
                ctx.clearRect(0, 0, canvas.offsetWidth, canvas.offsetHeight);
                startPos = null;
            }
        }
        /*]]>*/
    </script>
</div>
</body>
</html>
